<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Espalhamento Quântico (Final)</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f7f6;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column; /* Organiza os itens em coluna */
            align-items: center; /* Centraliza os itens horizontalmente */
        }
        .main-logo {
            max-width: 400px;
            margin-bottom: 20px;
        }
        .container {
            max-width: 900px;
            width: 100%;
            background: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .control-section, .info-section, .output-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1rem;
        }
        button {
            display: block;
            width: 100%;
            padding: 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .equation-container {
            text-align: center;
            margin: 20px 0;
        }
        .equation-container img {
            max-width: 100%;
            height: auto;
            background: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        #status {
            text-align: center;
            font-size: 1.1rem;
            color: #e67e22;
            padding: 15px;
            border-radius: 5px;
            background: #fdf2e9;
            margin-top: 20px;
            font-weight: bold;
        }
        #status pre {
            text-align: left; 
            color: red; 
            background: #fee; 
            padding: 10px; 
            border-radius: 5px; 
            white-space: pre-wrap; 
            word-wrap: break-word;
            margin-top: 10px;
        }
        #plot-output {
            text-align: center;
            margin-top: 20px;
        }
        #plot-output img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
    </style>
</head>
<body>
    
    <img src="MARCA_IFBA_HORIZONTAL_completa_CMYK_IFBA.png" alt="Logo do Instituto Federal da Bahia - IFBA" class="main-logo">

    <div class="container">
        <h1>Seção de Choque Diferencial na Primeira Aproximação de Born com Método Monte Carlo</h1>
        
        <div class="control-section">
            <h2>Configurações da Simulação</h2>
            <label for="potential-select">1. Escolha o Potencial de Espalhamento:</label>
            <select id="potential-select">
                <option value="rutherford">Rutherford (Coulomb)</option>
                <option value="poco_quadrado">Poço Quadrado Finito</option>
                <option value="yukawa">Yukawa</option>
                <option value="gaussiano">Gaussiano</option>
                <option value="woods_saxon">Woods-Saxon</option>
                <option value="lennard_jones">Lennard-Jones</option>
                <option value="morse">Morse</option>
            </select>
            
            <label>2. Ajuste os Parâmetros:</label>
            <div id="params-container" class="param-grid"></div>
             <div class="param-grid">
                <div>
                    <label for="mc_samples">Amostras Monte Carlo (N):</label>
                    <input type="number" id="mc_samples" value="100000" min="1" step="10">
                </div>
            </div>
            
            <button id="run-button">3. Simular</button>
        </div>

        <div class="info-section">
            <h2>Equações Utilizadas</h2>
            <p>A linha contínua representa o cálculo teórico (analítico ou numérico) e os pontos representam uma simulação via <strong>Método Monte Carlo</strong>.</p>
            <div id="potential-equation-container" class="equation-container">
                </div>
            <div id="potential-link-container" class="equation-container">
            </div>
        </div>

        <div class="output-section">
            <h2>Resultado</h2>
            <div id="status">Selecione os parâmetros e clique em "Simular".</div>
            <div id="plot-output"></div>
        </div>
    </div>

<script>
const potentialData = {
    rutherford: {
        name: "Rutherford (Coulomb)",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20%5Cfrac%7BZ_1%20Z_2%20e%5E2%7D%7B4%5Cpi%5Cepsilon_0%20r%7D",
        link: "https://pt.wikipedia.org/wiki/Dispers%C3%A3o_de_Rutherford",
        params: [
            { id: 'Z1', label: 'Carga Projétil (Z1)', value: 2, min: -1000 },
            { id: 'Z2', label: 'Carga Alvo (Z2)', value: 79, min: -1000 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 5, min: 1e-6 }
        ]
    },
    poco_quadrado: {
        name: "Poço Quadrado Finito",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20%5Cbegin%7Bcases%7D%20-V_0%20%26%20%5Ctext%7Bse%20%7D%20r%20%5Cle%20R%20%5C%5C%200%20%26%20%5Ctext%7Bse%20%7D%20r%20%3E%20R%20%5Cend%7Bcases%7D",
        link: "https://pt.wikipedia.org/wiki/Po%C3%A7o_de_potencial",
        params: [
            { id: 'V0_MeV', label: 'Profundidade V₀ (MeV)', value: 40, min: 1e-6 },
            { id: 'A', label: 'Número de Massa (A)', value: 48, min: 1 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 800, min: 1e-6 }
        ]
    },
    yukawa: {
        name: "Yukawa",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20-V_0%20%5Cfrac%7Be%5E%7B-r/a%7D%7D%7Br%7D",
        link: "https://pt.wikipedia.org/wiki/Potencial_de_Yukawa",
        params: [
            { id: 'V0_strength_MeV_fm', label: 'Força V₀·a (MeV·fm)', value: 60, min: 1e-6 },
            { id: 'a_fm', label: 'Alcance a (fm)', value: 1.4, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 10, min: 1e-6 }
        ]
    },
    gaussiano: {
        name: "Gaussiano",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20-V_0%20e%5E%7B-(r/a)%5E2%7D",
        link: "https://pt.wikipedia.org/wiki/Potencial_gaussiano",
        params: [
            { id: 'V0_MeV', label: 'Profundidade V₀ (MeV)', value: 40, min: 1e-6 },
            { id: 'a_fm', label: 'Largura a (fm)', value: 4.2, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 1, min: 1e-6 }
        ]
    },
     woods_saxon: {
        name: "Woods-Saxon",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20-%5Cfrac%7BV_0%7D%7B1%20&plus;%20e%5E%7B(r-R)/a%7D%7D",
        link: "https://en.wikipedia.org/wiki/Woods%E2%80%93Saxon_potential",
        params: [
            { id: 'V0_MeV', label: 'Profundidade V₀ (MeV)', value: 50, min: 1e-6 },
            { id: 'R_fm', label: 'Raio R (fm)', value: 5, min: 1e-6 },
            { id: 'a_fm', label: 'Difusividade a (fm)', value: 0.5, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 10, min: 1e-6 }
        ]
    },
    lennard_jones: {
        name: "Lennard-Jones",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%204%5Cepsilon%5Cleft%5B%20%5Cleft(%5Cfrac%7B%5Csigma%7D%7Br%7D%5Cright)%5E%7B12%7D%20-%20%5Cleft(%5Cfrac%7B%5Csigma%7D%7Br%7D%5Cright)%5E6%20%5Cright%5D",
        link: "https://pt.wikipedia.org/wiki/Potencial_de_Lennard-Jones",
        params: [
            { id: 'epsilon_eV', label: 'ε (eV)', value: 0.01, min: 1e-9 },
            { id: 'sigma_A', label: 'σ (Angstrom)', value: 3.4, min: 1e-9 },
            { id: 'E_eV', label: 'Energia (eV)', value: 0.01, min: 1e-9 }
        ]
    },
    morse: {
        name: "Morse",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20D_e%20%5Cleft(e%5E%7B-2a(r-r_e)%7D%20-2e%5E%7B-a(r-r_e)%7D%5Cright)",
        link: "https://pt.wikipedia.org/wiki/Potencial_de_Morse",
        params: [
            { id: 'De_eV', label: 'Dₑ (eV)', value: 3.0, min: 1e-9 },
            { id: 'a_A_inv', label: 'a (1/Angstrom)', value: 2.0, min: 1e-9 },
            { id: 're_A', label: 'rₑ (Angstrom)', value: 1.0, min: 1e-9 },
            { id: 'E_eV', label: 'Energia (eV)', value: 0.01, min: 1e-9 }
        ]
    }
};

const pythonScripts = {};

// --- SCRIPTS PYTHON ---

pythonScripts.rutherford = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64

def simulate(Z1, Z2, E_MeV, N_samples):
    e = 1.60218e-19
    epsilon_0 = 8.854187817e-12
    E_J = E_MeV * 1e6 * e
    N = int(N_samples)

    def sigma_rutherford(theta):
        safe_theta = np.maximum(theta, 1e-9)
        num = (Z1 * Z2 * e**2 / (4 * np.pi * epsilon_0 * 4 * E_J))**2
        denom = (np.sin(safe_theta / 2))**4
        return np.divide(num, denom).flatten()

    def sigma_mc(theta_bins, N_local):
        costheta = np.random.uniform(-1, 1, N_local)
        theta_samples = np.arccos(costheta)
        weights = sigma_rutherford(theta_samples)
        
        hist, edges = np.histogram(theta_samples, bins=theta_bins, weights=weights)
        bin_widths = np.diff(edges)
        bin_centers = 0.5 * (edges[:-1] + edges[1:])
        
        non_zero_widths = np.where(bin_widths > 0, bin_widths, 1)
        sigma_density = hist / (N_local * non_zero_widths)

        return bin_centers, sigma_density

    theta_bins = np.linspace(0.01, np.pi, 101)
    theta_ana_rad = np.linspace(np.radians(0.1), np.pi - np.radians(0.1), 500)
    
    sigma_ana_vals = sigma_rutherford(theta_ana_rad)
    theta_mc_rad, sigma_mc_vals = sigma_mc(theta_bins, N_local=N)

    plt.figure(figsize=(9, 6))
    plt.plot(np.degrees(theta_ana_rad), sigma_ana_vals, label='Rutherford (Analítica)', color='red', lw=2)
    plt.plot(np.degrees(theta_mc_rad), sigma_mc_vals, 'o', label=f'Monte Carlo (N={N})', color='blue', markersize=5)
    
    plt.xlabel('Ângulo de espalhamento θ (graus)')
    plt.ylabel('dσ/dΩ [m²/sr]')
    plt.title(f'Espalhamento Rutherford: E={E_MeV} MeV')
    plt.yscale('log')
    plt.legend()
    plt.grid(True, which='both', linestyle='--')
    plt.xlim(0, 180)
    
    if np.any(np.isfinite(sigma_ana_vals)):
        plt.ylim(bottom=1e-32, top=np.nanmax(sigma_ana_vals)*10)
    else:
        plt.ylim(bottom=1e-32, top=1)
    
    plt.tight_layout()

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('utf-8')
`;

pythonScripts.poco_quadrado = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64

def simulate(V0_MeV, A, E_MeV, N_samples):
    m_p, hbar, MeV_to_J, r0 = 1.6726e-27, 1.055e-34, 1.602e-13, 1.2e-15
    V0, E, R = V0_MeV * MeV_to_J, E_MeV * MeV_to_J, r0 * A**(1/3)
    k = np.sqrt(2 * m_p * E) / hbar
    N_samples = int(N_samples)

    def analytical_cs(theta):
        q = 2 * k * np.sin(theta / 2)
        if abs(q) < 1e-9: return np.nan
        qR = q * R
        f_q_term = (np.sin(qR) - qR * np.cos(qR)) / q**3
        return np.abs(2 * m_p * V0 / hbar**2 * f_q_term)**2
    
    def monte_carlo_cs(theta, N):
        q = 2 * k * np.sin(theta / 2)
        if abs(q) < 1e-9: return np.nan
        u = np.random.uniform(0, 1, N)
        r = R * (u**(1/3))
        cos_phi = np.random.uniform(-1, 1, N)
        z = r * cos_phi
        integrand = -V0 * np.cos(q * z)
        integral = (4/3) * np.pi * R**3 * np.mean(integrand)
        amplitude = -m_p / (2 * np.pi * hbar**2) * integral
        return np.abs(amplitude)**2

    angles_deg = np.linspace(1, 40, 100)
    cs_ana = [analytical_cs(t) for t in np.radians(angles_deg)]
    
    mc_angles_deg = np.linspace(1, 40, 100)
    cs_mc = [monte_carlo_cs(t, int(N_samples/10)) for t in np.radians(mc_angles_deg)]

    plt.figure(figsize=(9, 6))
    plt.plot(angles_deg, cs_ana, label='Analítico (Born)', color='red', lw=2)
    plt.plot(mc_angles_deg, cs_mc, 'o', label=f'Monte Carlo (N={N_samples})', color='blue')
    plt.yscale('log')
    plt.title(f'Espalhamento por Poço Quadrado (E={E_MeV} MeV)')
    plt.xlabel('Ângulo de espalhamento θ (graus)')
    plt.ylabel('dσ/dΩ [m²/sr]')
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.tight_layout()
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('utf-8')
`;

pythonScripts.yukawa = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64
import cmath

def simulate(V0_strength_MeV_fm, a_fm, E_MeV, N_samples):
    m_p, hbar, MeV_to_J, fm_to_m = 1.6726e-27, 1.055e-34, 1.602e-13, 1e-15
    E = E_MeV * MeV_to_J
    a_yukawa = a_fm * fm_to_m
    V_strength = V0_strength_MeV_fm * MeV_to_J * fm_to_m
    N = int(N_samples)
    R_max = a_yukawa * 8.0

    def V_yukawa(r_vec):
        norm_r = np.linalg.norm(r_vec)
        if norm_r == 0: return 0.0
        return -V_strength * np.exp(-norm_r / a_yukawa) / norm_r

    def born_amplitude_yukawa_mc(theta):
        k = np.sqrt(2 * m_p * E) / hbar
        q_mag = 2 * k * np.sin(theta / 2)
        q = np.array([0, 0, q_mag])
        r_samples = np.random.uniform(-R_max, R_max, (N, 3))
        dot_product = np.dot(r_samples, q)
        V_values = np.apply_along_axis(V_yukawa, 1, r_samples)
        integrand = np.exp(1j * dot_product) * V_values
        integral = (2*R_max)**3 * np.sum(integrand) / N
        return -m_p / (2 * np.pi * hbar**2) * integral

    def differential_cross_section_yukawa_mc(theta):
        return np.abs(born_amplitude_yukawa_mc(theta))**2

    def analytical_cross_section_yukawa(theta):
        k = np.sqrt(2 * m_p * E) / hbar
        q = 2 * k * np.sin(theta / 2)
        f_q = (2 * m_p * V_strength / hbar**2) / (q**2 + (1/a_yukawa)**2)
        return np.abs(f_q)**2

    angles_deg_ana = np.linspace(1, 90, 100)
    cross_sections_analytical = [analytical_cross_section_yukawa(t) for t in np.radians(angles_deg_ana)]
    
    angles_deg_mc = np.linspace(1, 90, 100)
    cross_sections_mc = [differential_cross_section_yukawa_mc(t) for t in np.radians(angles_deg_mc)]

    plt.figure(figsize=(9, 6))
    plt.plot(angles_deg_ana, cross_sections_analytical, label='Analítico (Yukawa)', color='red', lw=2)
    plt.plot(angles_deg_mc, cross_sections_mc, 'o', label=f'Monte Carlo (N={N})', color='blue')
    plt.yscale('log')
    plt.title(f'Espalhamento Yukawa (E={E_MeV} MeV)')
    plt.xlabel("Ângulo de espalhamento θ (graus)")
    plt.ylabel("dσ/dΩ [m²/sr]")
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.tight_layout()
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('utf-8')
`;

pythonScripts.gaussiano = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64

def simulate(V0_MeV, a_fm, E_MeV, N_samples):
    m_p, hbar, MeV_to_J, fm_to_m = 1.6726e-27, 1.055e-34, 1.602e-13, 1e-15
    V0, a_gauss, E = V0_MeV * MeV_to_J, a_fm * fm_to_m, E_MeV * MeV_to_J
    N = int(N_samples)
    R_max = 3 * a_gauss

    def V_gaussian(r_vec):
        norm_r = np.linalg.norm(r_vec)
        return -V0 * np.exp(-(norm_r / a_gauss)**2)

    def born_amplitude_gaussian_mc(theta):
        k = np.sqrt(2 * m_p * E) / hbar
        q_mag = 2 * k * np.sin(theta / 2)
        q = np.array([0, 0, q_mag])
        
        r_samples = np.random.uniform(-R_max, R_max, (N, 3))
        r_norms = np.linalg.norm(r_samples, axis=1)
        valid_indices = r_norms <= R_max
        r_valid = r_samples[valid_indices]
        
        if len(r_valid) == 0: return 0
        
        dot_product = np.dot(r_valid, q)
        V_values = -V0 * np.exp(-(np.linalg.norm(r_valid, axis=1) / a_gauss)**2)
        integrand = np.exp(1j * dot_product) * V_values
        
        volume = (4/3) * np.pi * R_max**3
        integral = volume * np.sum(integrand) / len(r_valid)
        return -m_p / (2 * np.pi * hbar**2) * integral

    def differential_cross_section_gaussian_mc(theta):
        return np.abs(born_amplitude_gaussian_mc(theta))**2

    def analytical_cross_section_gaussian(theta):
        k = np.sqrt(2 * m_p * E) / hbar
        q = 2 * k * np.sin(theta / 2)
        prefactor_f = (m_p * V0 * (np.sqrt(np.pi) * a_gauss)**3) / (2 * np.pi * hbar**2)
        exp_term = np.exp(-(q * a_gauss)**2 / 4)
        return np.abs(prefactor_f * exp_term)**2

    angles_deg = np.linspace(1, 90, 100)
    cs_analytical = [analytical_cross_section_gaussian(t) for t in np.radians(angles_deg)]
    
    mc_angles_deg = np.linspace(1, 90, 100)
    cs_mc = [differential_cross_section_gaussian_mc(t) for t in np.radians(mc_angles_deg)]

    plt.figure(figsize=(9, 6))
    plt.plot(angles_deg, cs_analytical, label='Analítico (Gaussiano)', color='red', lw=2)
    plt.plot(mc_angles_deg, cs_mc, 'o', label=f'Monte Carlo (N={N})', color='blue')
    plt.yscale('log')
    plt.title(f'Espalhamento Gaussiano (E={E_MeV} MeV)')
    plt.xlabel("Ângulo de espalhamento θ (graus)")
    plt.ylabel("dσ/dΩ [m²/sr]")
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.tight_layout()
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('utf-8')
`;

const genericNumericalScript = `
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
import io, base64

def simulate(potential_type, N_samples, **params):
    hbar, m_p, MeV_to_J, fm_to_m, eV_to_J, A_to_m = 1.05457e-34, 1.6726e-27, 1.602e-13, 1e-15, 1.602e-19, 1e-10
    N_samples = int(N_samples)
    
    if potential_type == 'woods_saxon' or potential_type == 'morse':
        if potential_type == 'woods_saxon':
            V0, R, a, E_J = params['V0_MeV']*MeV_to_J, params['R_fm']*fm_to_m, params['a_fm']*fm_to_m, params['E_MeV']*MeV_to_J
            m, r_max = m_p, 20 * fm_to_m
            potential = lambda r: -V0 / (1 + np.exp((r - R) / a))
            title = f"Espalhamento Woods-Saxon (E={params['E_MeV']} MeV)"
        else: # Morse
            De, a, re, E_J = params['De_eV']*eV_to_J, params['a_A_inv']/A_to_m, params['re_A']*A_to_m, params['E_eV']*eV_to_J
            m, r_max = m_p, 5 * re
            potential = lambda r: De * (np.exp(-2 * a * (r - re)) - 2 * np.exp(-a * (r - re)))
            title = f"Espalhamento Morse (E={params['E_eV']} eV)"

        k = np.sqrt(2 * m * E_J) / hbar
        
        def numerical_cs(theta):
            q = 2 * k * np.sin(theta / 2)
            if abs(q) < 1e-9: return np.nan
            integrand = lambda r: r * potential(r) * np.sin(q * r)
            integral, _ = quad(integrand, 1e-15, r_max, limit=100)
            amplitude = - (2 * m / (hbar**2 * q)) * integral
            return abs(amplitude)**2

        def monte_carlo_cs(theta, N):
            q = 2 * k * np.sin(theta / 2)
            if abs(q) < 1e-9: return np.nan
            x, y, z = np.random.uniform(-r_max, r_max, (3, N))
            r = np.sqrt(x**2 + y**2 + z**2)
            r = np.maximum(r, 1e-20)
            integrand = np.where(r > 0, potential(r), 0) * np.cos(q * z)
            integral = (2 * r_max)**3 * np.mean(integrand)
            amplitude = -m / (2 * np.pi * hbar**2) * integral
            return np.abs(amplitude)**2
            
        theta_ana = np.linspace(0.02, np.pi, 100)
        cs_ana = [numerical_cs(t) for t in theta_ana]
        
        theta_mc_deg = np.linspace(5, 175, 100)
        cs_mc = [monte_carlo_cs(t, int(N_samples/10)) for t in np.radians(theta_mc_deg)]

        plt.figure(figsize=(9, 6))
        plt.plot(np.degrees(theta_ana), cs_ana, label='Numérico (Born)', lw=2, color='red')
        plt.plot(theta_mc_deg, cs_mc, 'o', label=f'Monte Carlo (N={N_samples})', color='blue')
        plt.yscale('log')

    elif potential_type == 'lennard_jones':
        epsilon, sigma, E_J = params['epsilon_eV']*eV_to_J, params['sigma_A']*A_to_m, params['E_eV']*eV_to_J
        m = m_p
        title = f"Espalhamento Lennard-Jones (E={params['E_eV']} eV)"
        
        def lennard_jones_pot(r):
            r_safe = np.maximum(np.asarray(r), 1e-12)
            return 4 * epsilon * ((sigma / r_safe)**12 - (sigma / r_safe)**6)

        def born_amplitude(q):
            if q < 1e-9: return 0
            integrand = lambda r: lennard_jones_pot(r) * np.sin(q * r) / q * r**2
            result, _ = quad(integrand, 0.5 * sigma, 5 * sigma, limit=100)
            return - (2 * m / hbar**2) * result
            
        def numerical_cs(theta):
            k = np.sqrt(2 * m * E_J) / hbar
            q = 2 * k * np.sin(theta / 2)
            f_q = born_amplitude(q)
            return abs(f_q)**2

        def born_amplitude_mc(q, N_local):
            if q < 1e-9: return 0
            r_vals = np.random.uniform(0.5 * sigma, 5 * sigma, N_local)
            weights = lennard_jones_pot(r_vals) * np.sin(q * r_vals) / q * r_vals**2
            volume = 4.5 * sigma
            integral = np.mean(weights) * volume
            return - (2 * m / hbar**2) * integral
            
        def monte_carlo_cs(theta, N_local):
            k = np.sqrt(2 * m * E_J) / hbar
            q = 2 * k * np.sin(theta / 2)
            f_q = born_amplitude_mc(q, N_local)
            return abs(f_q)**2
        
        theta_ana = np.linspace(0.02, np.pi, 100)
        cs_ana = [numerical_cs(t) for t in theta_ana]
        
        theta_mc_rad = np.linspace(0.02, np.pi, 100)
        cs_mc = [monte_carlo_cs(t, int(N_samples/10)) for t in theta_mc_rad]
        
        plt.figure(figsize=(9, 6))
        plt.plot(np.degrees(theta_ana), cs_ana, label='Born (Integração Numérica)', lw=2, color='red')
        plt.plot(np.degrees(theta_mc_rad), cs_mc,'o', label=f'Born (Monte Carlo N={N_samples})', color='blue')
        plt.yscale('log')

    plt.xlabel('Ângulo de espalhamento (graus)')
    plt.ylabel('dσ/dΩ [m²/sr]')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    return base64.b64encode(buf.read()).decode('utf-8')
`;

pythonScripts.woods_saxon = genericNumericalScript;
pythonScripts.lennard_jones = genericNumericalScript;
pythonScripts.morse = genericNumericalScript;


// --- PAGE LOGIC ---
const select = document.getElementById('potential-select');
const paramsContainer = document.getElementById('params-container');
const potentialEquationContainer = document.getElementById('potential-equation-container');
const potentialLinkContainer = document.getElementById('potential-link-container');
const runButton = document.getElementById('run-button');
const statusDiv = document.getElementById('status');
const plotOutput = document.getElementById('plot-output');
let pyodide;

function updateUI() {
    const selected = select.value;
    const data = potentialData[selected];
    paramsContainer.innerHTML = '';
    
    data.params.forEach(param => {
        const div = document.createElement('div');
        const label = document.createElement('label');
        label.setAttribute('for', param.id);
        label.textContent = param.label + ':';
        
        const input = document.createElement('input');
        input.type = 'number';
        input.id = param.id;
        input.value = param.value;
        input.step = "any";
        if (param.min !== undefined) input.min = param.min;
        div.appendChild(label);
        div.appendChild(input);
        paramsContainer.appendChild(div);
    });
    potentialEquationContainer.innerHTML = `<img src="${data.equation}" alt="Equação para ${data.name}">`;
    // Adiciona o link explicativo
    potentialLinkContainer.innerHTML = `<a href="${data.link}" target="_blank" rel="noopener noreferrer">Saiba mais sobre o Potencial de ${data.name}</a>`;
}

async function runSimulation() {
    statusDiv.textContent = 'Calculando... Por favor, aguarde.';
    runButton.disabled = true;
    plotOutput.innerHTML = '';

    try {
        const selected = select.value;
        const script = pythonScripts[selected];
        
        const params = {};
        potentialData[selected].params.forEach(param => {
            params[param.id] = parseFloat(document.getElementById(param.id).value);
        });
        params['N_samples'] = parseFloat(document.getElementById('mc_samples').value);
        
        // Adiciona o tipo de potencial APENAS se estiver usando o script genérico
        if (script === genericNumericalScript){
            params['potential_type'] = selected;
        }

        await pyodide.runPythonAsync(script);
        
        let pyParams = pyodide.toPy(params);
        pyodide.globals.set("py_params", pyParams);
        
        const image_base_64 = await pyodide.runPythonAsync("simulate(**py_params)");
        
        plotOutput.innerHTML = `<img src="data:image/png;base64,${image_base_64}" alt="Gráfico do resultado da simulação"/>`;
        statusDiv.textContent = 'Simulação concluída com sucesso!';
        
        pyParams.destroy();

    } catch (error) {
        statusDiv.innerHTML = `Ocorreu um erro durante a simulação.<pre>${error.toString()}</pre>`;
        console.error("Pyodide Error:", error);
    } finally {
        runButton.disabled = false;
    }
}

async function main() {
    statusDiv.textContent = 'Carregando ambiente Python (Pyodide)... Isso pode levar um momento.';
    runButton.disabled = true;
    try {
        pyodide = await loadPyodide();
        await pyodide.loadPackage(['numpy', 'matplotlib', 'scipy']);
        statusDiv.textContent = 'Ambiente pronto. Selecione os parâmetros e clique em "Simular".';
        runButton.disabled = false;
    } catch (error) {
        statusDiv.innerHTML = `Falha ao carregar o ambiente Python.<pre>${error.toString()}</pre>`;
        console.error("Pyodide loading error:", error);
    }
}

select.addEventListener('change', updateUI);
runButton.addEventListener('click', runSimulation);

document.addEventListener('DOMContentLoaded', () => {
    updateUI();
    main();
});
</script>
</body>
</html>
