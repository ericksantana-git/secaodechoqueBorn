<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Espalhamento Quântico (Final)</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f7f6;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column; /* Organiza os itens em coluna */
            align-items: center; /* Centraliza os itens horizontalmente */
        }
        .main-logo {
            max-width: 400px;
            margin-bottom: 20px;
        }
        .container {
            max-width: 900px;
            width: 100%;
            background: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .control-section, .info-section, .output-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1rem;
        }
        button {
            display: block;
            width: 100%;
            padding: 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px; /* Espaçamento entre botões */
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        #save-button {
            background-color: #27ae60; /* Cor verde para o botão de salvar */
            margin-top: 20px; /* Adicionado espaço extra acima do botão salvar */
        }
        #save-button:hover {
            background-color: #229954;
        }
        .equation-container {
            text-align: center;
            margin: 20px 0;
        }
        .equation-container img {
            max-width: 100%;
            height: auto;
            background: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        #status {
            text-align: center;
            font-size: 1.1rem;
            color: #e67e22;
            padding: 15px;
            border-radius: 5px;
            background: #fdf2e9;
            margin-top: 20px;
            font-weight: bold;
        }
        #status pre {
            text-align: left;
            color: red;
            background: #fee;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-top: 10px;
        }
        #plot-output {
            text-align: center;
            margin-top: 20px;
        }
        #plot-output img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
    </style>
</head>
<body>

    <img src="MARCA_IFBA_HORIZONTAL_completa_CMYK_IFBA.png" alt="Logo do Instituto Federal da Bahia - IFBA" class="main-logo">

    <div class="container">
        <h1>Seção de Choque Diferencial na Primeira Aproximação de Born com Método Monte Carlo</h1>

        <div class="control-section">
            <h2>Configurações da Simulação</h2>
            <label for="potential-select">1. Escolha o Potencial de Espalhamento:</label>
            <select id="potential-select">
                <option value="rutherford">Rutherford (Coulomb)</option>
                <option value="poco_quadrado">Poço Quadrado Finito</option>
                <option value="yukawa">Yukawa</option>
                <option value="gaussiano">Gaussiano</option>
                <option value="woods_saxon">Woods-Saxon</option>
                <option value="lennard_jones">Lennard-Jones</option>
                <option value="morse">Morse</option>
            </select>

            <label>2. Ajuste os Parâmetros:</label>
            <div class="param-grid">
                <div>
                    <label for="particle-select">Partícula Incidente:</label>
                    <select id="particle-select"></select>
                </div>
                <div>
                    <label for="target-select">Elemento Alvo:</label>
                    <select id="target-select"></select>
                </div>
            </div>
            <div id="params-container" class="param-grid"></div>
             <div class="param-grid">
                <div>
                    <label for="mc_samples">Amostras Monte Carlo (N):</label>
                    <input type="number" id="mc_samples" value="100000" min="1" step="10">
                </div>
            </div>

            <button id="run-button">3. Simular</button>
        </div>

        <div class="info-section">
            <h2>Equações Utilizadas</h2>
            <p>A linha contínua representa o cálculo teórico (analítico ou numérico) e os pontos representam uma simulação via <strong>Método Monte Carlo</strong>.</p>
            <div id="potential-equation-container" class="equation-container">
                </div>
            <div id="potential-link-container" class="equation-container">
            </div>
        </div>

        <div class="output-section">
            <h2>Resultado</h2>
            <div id="status">Selecione os parâmetros e clique em "Simular".</div>
            <div id="plot-output"></div>
        </div>
        
        <button id="save-button" disabled>4. Salvar Dados (Excel)</button>
    </div>

<script>
// --- DATA ---
const particleData = {
    // Partículas originais
    electron: { name: 'Elétron', mass_kg: 9.10938356e-31, charge_z: -1 },
    proton: { name: 'Próton', mass_kg: 1.6726219e-27, charge_z: 1 },
    alpha: { name: 'Partícula Alfa (He-4)', mass_kg: 6.64465723e-27, charge_z: 2 },

    // --- Léptons ---
    muon: { name: 'Múon', mass_kg: 1.883531627e-28, charge_z: -1 },
    tau: { name: 'Tau', mass_kg: 3.16747e-27, charge_z: -1 },

    // --- Hádrons ---
    neutron: { name: 'Nêutron', mass_kg: 1.67492749e-27, charge_z: 0 },
    pion_pos: { name: 'Píon (+)', mass_kg: 2.48807e-28, charge_z: 1 },
    pion_neg: { name: 'Píon (-)', mass_kg: 2.48807e-28, charge_z: -1 },
    pion_zero: { name: 'Píon (0)', mass_kg: 2.40618e-28, charge_z: 0 },
    kaon_pos: { name: 'Kaon (+)', mass_kg: 8.7997e-28, charge_z: 1 },
    kaon_neg: { name: 'Kaon (-)', mass_kg: 8.7997e-28, charge_z: -1 },
    kaon_zero: { name: 'Kaon (0)', mass_kg: 8.8701e-28, charge_z: 0 },

    // --- Núcleos Leves e Íons ---
    deuteron: { name: 'Dêuteron (H-2)', mass_kg: 3.343583719e-27, charge_z: 1 },
    triton: { name: 'Tríton (H-3)', mass_kg: 5.00735675e-27, charge_z: 1 },
    helion: { name: 'Hélion (He-3)', mass_kg: 5.0064127e-27, charge_z: 2 },
    carbon12_ion: { name: 'Íon de Carbono-12', mass_kg: 1.9926468e-26, charge_z: 6 },
    oxygen16_ion: { name: 'Íon de Oxigênio-16', mass_kg: 2.656018e-26, charge_z: 8 }
};

const targetData = {
    H: { name: 'Hidrogênio', Z: 1, A: 1 },  He: { name: 'Hélio', Z: 2, A: 4 },
    Li: { name: 'Lítio', Z: 3, A: 7 },     Be: { name: 'Berílio', Z: 4, A: 9 },
    C: { name: 'Carbono', Z: 6, A: 12 },   N: { name: 'Nitrogênio', Z: 7, A: 14 },
    O: { name: 'Oxigênio', Z: 8, A: 16 },  Al: { name: 'Alumínio', Z: 13, A: 27 },
    Si: { name: 'Silício', Z: 14, A: 28 }, Ar: { name: 'Argônio', Z: 18, A: 40 },
    Ca: { name: 'Cálcio', Z: 20, A: 40 },  Fe: { name: 'Ferro', Z: 26, A: 56 },
    Cu: { name: 'Cobre', Z: 29, A: 64 },   Ag: { name: 'Prata', Z: 47, A: 108 },
    Au: { name: 'Ouro', Z: 79, A: 197 },   Pb: { name: 'Chumbo', Z: 82, A: 207 },
    U: { name: 'Urânio', Z: 92, A: 238 }
};

const potentialData = {
    rutherford: {
        name: "Rutherford (Coulomb)",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20%5Cfrac%7BZ_1%20Z_2%20e%5E2%7D%7B4%5Cpi%5Cepsilon_0%20r%7D",
        link: "https://pt.wikipedia.org/wiki/Dispers%C3%A3o_de_Rutherford",
        params: [
            { id: 'E_MeV', label: 'Energia (MeV)', value: 5, min: 1e-6 }
        ]
    },
    poco_quadrado: {
        name: "Poço Quadrado Finito",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20%5Cbegin%7Bcases%7D%20-V_0%20%26%20%5Ctext%7Bse%20%7D%20r%20%5Cle%20R%20%5C%5C%200%20%26%20%5Ctext%7Bse%20%7D%20r%20%3E%20R%20%5Cend%7Bcases%7D",
        link: "https://pt.wikipedia.org/wiki/Po%C3%A7o_de_potencial",
        params: [
            { id: 'V0_MeV', label: 'Profundidade V₀ (MeV)', value: 40, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 800, min: 1e-6 }
        ]
    },
    yukawa: {
        name: "Yukawa",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20-V_0%20%5Cfrac%7Be%5E%7B-r/a%7D%7D%7Br%7D",
        link: "https://pt.wikipedia.org/wiki/Potencial_de_Yukawa",
        params: [
            { id: 'V0_strength_MeV_fm', label: 'Força V₀·a (MeV·fm)', value: 60, min: 1e-6 },
            { id: 'a_fm', label: 'Alcance a (fm)', value: 1.4, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 10, min: 1e-6 }
        ]
    },
    gaussiano: {
        name: "Gaussiano",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20-V_0%20e%5E%7B-(r/a)%5E2%7D",
        link: "https://pt.wikipedia.org/wiki/Potencial_gaussiano",
        params: [
            { id: 'V0_MeV', label: 'Profundidade V₀ (MeV)', value: 40, min: 1e-6 },
            { id: 'a_fm', label: 'Largura a (fm)', value: 4.2, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 1, min: 1e-6 }
        ]
    },
     woods_saxon: {
        name: "Woods-Saxon",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20-%5Cfrac%7BV_0%7D%7B1%20&plus;%20e%5E%7B(r-R)/a%7D%7D",
        link: "https://en.wikipedia.org/wiki/Woods%E2%80%93Saxon_potential",
        params: [
            { id: 'V0_MeV', label: 'Profundidade V₀ (MeV)', value: 50, min: 1e-6 },
            { id: 'R_fm', label: 'Raio R (fm)', value: 5, min: 1e-6 },
            { id: 'a_fm', label: 'Difusividade a (fm)', value: 0.5, min: 1e-6 },
            { id: 'E_MeV', label: 'Energia (MeV)', value: 10, min: 1e-6 }
        ]
    },
    lennard_jones: {
        name: "Lennard-Jones",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%204%5Cepsilon%5Cleft%5B%20%5Cleft(%5Cfrac%7B%5Csigma%7D%7Br%7D%5Cright)%5E%7B12%7D%20-%20%5Cleft(%5Cfrac%7B%5Csigma%7D%7Br%7D%5Cright)%5E6%20%5Cright%5D",
        link: "https://pt.wikipedia.org/wiki/Potencial_de_Lennard-Jones",
        params: [
            { id: 'epsilon_eV', label: 'ε (eV)', value: 0.01, min: 1e-9 },
            { id: 'sigma_A', label: 'σ (Angstrom)', value: 3.4, min: 1e-9 },
            { id: 'E_eV', label: 'Energia (eV)', value: 0.01, min: 1e-9 }
        ]
    },
    morse: {
        name: "Morse",
        equation: "https://latex.codecogs.com/png.latex?%5Cdpi%7B150%7D%20V(r)%20%3D%20D_e%20%5Cleft(e%5E%7B-2a(r-r_e)%7D%20-2e%5E%7B-a(r-r_e)%7D%5Cright)",
        link: "https://pt.wikipedia.org/wiki/Potencial_de_Morse",
        params: [
            { id: 'De_eV', label: 'Dₑ (eV)', value: 3.0, min: 1e-9 },
            { id: 'a_A_inv', label: 'a (1/Angstrom)', value: 2.0, min: 1e-9 },
            { id: 're_A', label: 'rₑ (Angstrom)', value: 1.0, min: 1e-9 },
            { id: 'E_eV', label: 'Energia (eV)', value: 0.01, min: 1e-9 }
        ]
    }
};

const pythonScripts = {};

// --- SCRIPTS PYTHON ---

pythonScripts.rutherford = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64, json

def simulate(Z1, Z2, E_MeV, N_samples, m_projectile_kg):
    e = 1.60218e-19
    epsilon_0 = 8.854187817e-12
    E_J = E_MeV * 1e6 * e
    N = int(N_samples)

    def sigma_rutherford(theta):
        safe_theta = np.maximum(theta, 1e-9)
        num = (Z1 * Z2 * e**2 / (4 * np.pi * epsilon_0 * 4 * E_J))**2
        denom = (np.sin(safe_theta / 2))**4
        return np.divide(num, denom).flatten()

    def sigma_mc(theta_bins, N_local):
        costheta = np.random.uniform(-1, 1, N_local)
        theta_samples = np.arccos(costheta)
        weights = sigma_rutherford(theta_samples)
        
        hist, edges = np.histogram(theta_samples, bins=theta_bins, weights=weights)
        bin_widths = np.diff(edges)
        bin_centers = 0.5 * (edges[:-1] + edges[1:])
        
        non_zero_widths = np.where(bin_widths > 0, bin_widths, 1)
        sigma_density = hist / (N_local * non_zero_widths)

        return bin_centers, sigma_density

    theta_bins = np.linspace(0.01, np.pi, 101)
    theta_ana_rad = np.linspace(np.radians(0.1), np.pi - np.radians(0.1), 500)
    
    sigma_ana_vals = sigma_rutherford(theta_ana_rad)
    theta_mc_rad, sigma_mc_vals = sigma_mc(theta_bins, N_local=N)

    plt.figure(figsize=(9, 6))
    plt.plot(np.degrees(theta_ana_rad), sigma_ana_vals, label='Rutherford (Analítica)', color='red', lw=2)
    plt.plot(np.degrees(theta_mc_rad), sigma_mc_vals, 'o', label=f'Monte Carlo (N={N})', color='blue', markersize=5)
    
    plt.xlabel('Ângulo de espalhamento θ (graus)')
    plt.ylabel('dσ/dΩ [m²/sr]')
    plt.title(f'Espalhamento Rutherford: E={E_MeV} MeV')
    plt.yscale('log')
    plt.legend()
    plt.grid(True, which='both', linestyle='--')
    plt.xlim(0, 180)
    
    if np.any(np.isfinite(sigma_ana_vals)):
        plt.ylim(bottom=1e-32, top=np.nanmax(sigma_ana_vals)*10)
    else:
        plt.ylim(bottom=1e-32, top=1)
    
    plt.tight_layout()

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()

    results = {
        "plot": img_b64,
        "data": {
            "angle_ana_deg": np.degrees(theta_ana_rad).tolist(),
            "cs_ana_m2_sr": sigma_ana_vals.tolist(),
            "angle_mc_deg": np.degrees(theta_mc_rad).tolist(),
            "cs_mc_m2_sr": sigma_mc_vals.tolist()
        }
    }
    return json.dumps(results)
`;

pythonScripts.poco_quadrado = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64, json

def simulate(V0_MeV, A, E_MeV, N_samples, m_projectile_kg):
    hbar, MeV_to_J, r0 = 1.055e-34, 1.602e-13, 1.2e-15
    V0, E, R = V0_MeV * MeV_to_J, E_MeV * MeV_to_J, r0 * A**(1/3)
    k = np.sqrt(2 * m_projectile_kg * E) / hbar
    N_samples = int(N_samples)

    def analytical_cs(theta):
        q = 2 * k * np.sin(theta / 2)
        if abs(q) < 1e-9: return np.nan
        qR = q * R
        f_q_term = (np.sin(qR) - qR * np.cos(qR)) / q**3
        return np.abs(2 * m_projectile_kg * V0 / hbar**2 * f_q_term)**2
    
    def monte_carlo_cs(theta, N):
        q = 2 * k * np.sin(theta / 2)
        if abs(q) < 1e-9: return np.nan
        u = np.random.uniform(0, 1, N)
        r = R * (u**(1/3))
        cos_phi = np.random.uniform(-1, 1, N)
        z = r * cos_phi
        integrand = -V0 * np.cos(q * z)
        integral = (4/3) * np.pi * R**3 * np.mean(integrand)
        amplitude = -m_projectile_kg / (2 * np.pi * hbar**2) * integral
        return np.abs(amplitude)**2

    angles_deg = np.linspace(1, 40, 100)
    angles_rad = np.radians(angles_deg)
    cs_ana = [analytical_cs(t) for t in angles_rad]
    
    mc_angles_deg = np.linspace(1, 40, 100) # Reduzido para performance
    mc_angles_rad = np.radians(mc_angles_deg)
    cs_mc = [monte_carlo_cs(t, int(N_samples/100)) for t in mc_angles_rad]

    plt.figure(figsize=(9, 6))
    plt.plot(angles_deg, cs_ana, label='Analítico (Born)', color='red', lw=2)
    plt.plot(mc_angles_deg, cs_mc, 'o', label=f'Monte Carlo (N={N_samples})', color='blue')
    plt.yscale('log')
    plt.title(f'Espalhamento por Poço Quadrado (E={E_MeV} MeV)')
    plt.xlabel('Ângulo de espalhamento θ (graus)')
    plt.ylabel('dσ/dΩ [m²/sr]')
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.tight_layout()
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()

    results = {
        "plot": img_b64,
        "data": {
            "angle_ana_deg": angles_deg.tolist(),
            "cs_ana_m2_sr": cs_ana,
            "angle_mc_deg": mc_angles_deg.tolist(),
            "cs_mc_m2_sr": cs_mc
        }
    }
    return json.dumps(results)
`;

pythonScripts.yukawa = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64, json
import cmath

def simulate(V0_strength_MeV_fm, a_fm, E_MeV, N_samples, m_projectile_kg):
    hbar, MeV_to_J, fm_to_m = 1.055e-34, 1.602e-13, 1e-15
    E = E_MeV * MeV_to_J
    a_yukawa = a_fm * fm_to_m
    V_strength = V0_strength_MeV_fm * MeV_to_J * fm_to_m
    N = int(N_samples)
    R_max = a_yukawa * 8.0

    def V_yukawa(r_vec):
        norm_r = np.linalg.norm(r_vec)
        if norm_r == 0: return 0.0
        return -V_strength * np.exp(-norm_r / a_yukawa) / norm_r

    def born_amplitude_yukawa_mc(theta):
        k = np.sqrt(2 * m_projectile_kg * E) / hbar
        q_mag = 2 * k * np.sin(theta / 2)
        q = np.array([0, 0, q_mag])
        r_samples = np.random.uniform(-R_max, R_max, (N, 3))
        dot_product = np.dot(r_samples, q)
        V_values = np.apply_along_axis(V_yukawa, 1, r_samples)
        integrand = np.exp(1j * dot_product) * V_values
        integral = (2*R_max)**3 * np.sum(integrand) / N
        return -m_projectile_kg / (2 * np.pi * hbar**2) * integral

    def differential_cross_section_yukawa_mc(theta):
        return np.abs(born_amplitude_yukawa_mc(theta))**2

    def analytical_cross_section_yukawa(theta):
        k = np.sqrt(2 * m_projectile_kg * E) / hbar
        q = 2 * k * np.sin(theta / 2)
        f_q = (2 * m_projectile_kg * V_strength / hbar**2) / (q**2 + (1/a_yukawa)**2)
        return np.abs(f_q)**2

    angles_deg_ana = np.linspace(1, 90, 100)
    angles_rad_ana = np.radians(angles_deg_ana)
    cross_sections_analytical = [analytical_cross_section_yukawa(t) for t in angles_rad_ana]
    
    angles_deg_mc = np.linspace(1, 90, 100) # Reduzido para performance
    angles_rad_mc = np.radians(angles_deg_mc)
    cross_sections_mc = [differential_cross_section_yukawa_mc(t) for t in angles_rad_mc]

    plt.figure(figsize=(9, 6))
    plt.plot(angles_deg_ana, cross_sections_analytical, label='Analítico (Yukawa)', color='red', lw=2)
    plt.plot(angles_deg_mc, cross_sections_mc, 'o', label=f'Monte Carlo (N={N})', color='blue')
    plt.yscale('log')
    plt.title(f'Espalhamento Yukawa (E={E_MeV} MeV)')
    plt.xlabel("Ângulo de espalhamento θ (graus)")
    plt.ylabel("dσ/dΩ [m²/sr]")
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.tight_layout()
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()

    results = {
        "plot": img_b64,
        "data": {
            "angle_ana_deg": angles_deg_ana.tolist(),
            "cs_ana_m2_sr": cross_sections_analytical,
            "angle_mc_deg": angles_deg_mc.tolist(),
            "cs_mc_m2_sr": cross_sections_mc
        }
    }
    return json.dumps(results)
`;

pythonScripts.gaussiano = `
import numpy as np
import matplotlib.pyplot as plt
import io, base64, json

def simulate(V0_MeV, a_fm, E_MeV, N_samples, m_projectile_kg):
    hbar, MeV_to_J, fm_to_m = 1.055e-34, 1.602e-13, 1e-15
    V0, a_gauss, E = V0_MeV * MeV_to_J, a_fm * fm_to_m, E_MeV * MeV_to_J
    N = int(N_samples)
    R_max = 3 * a_gauss

    def V_gaussian(r_vec):
        norm_r = np.linalg.norm(r_vec)
        return -V0 * np.exp(-(norm_r / a_gauss)**2)

    def born_amplitude_gaussian_mc(theta):
        k = np.sqrt(2 * m_projectile_kg * E) / hbar
        q_mag = 2 * k * np.sin(theta / 2)
        q = np.array([0, 0, q_mag])
        
        r_samples = np.random.uniform(-R_max, R_max, (N, 3))
        r_norms = np.linalg.norm(r_samples, axis=1)
        valid_indices = r_norms <= R_max
        r_valid = r_samples[valid_indices]
        
        if len(r_valid) == 0: return 0
        
        dot_product = np.dot(r_valid, q)
        V_values = -V0 * np.exp(-(np.linalg.norm(r_valid, axis=1) / a_gauss)**2)
        integrand = np.exp(1j * dot_product) * V_values
        
        volume = (4/3) * np.pi * R_max**3
        integral = volume * np.sum(integrand) / len(r_valid)
        return -m_projectile_kg / (2 * np.pi * hbar**2) * integral

    def differential_cross_section_gaussian_mc(theta):
        return np.abs(born_amplitude_gaussian_mc(theta))**2

    def analytical_cross_section_gaussian(theta):
        k = np.sqrt(2 * m_projectile_kg * E) / hbar
        q = 2 * k * np.sin(theta / 2)
        prefactor_f = (m_projectile_kg * V0 * (np.sqrt(np.pi) * a_gauss)**3) / (2 * np.pi * hbar**2)
        exp_term = np.exp(-(q * a_gauss)**2 / 4)
        return np.abs(prefactor_f * exp_term)**2

    angles_deg = np.linspace(1, 90, 100)
    angles_rad = np.radians(angles_deg)
    cs_analytical = [analytical_cross_section_gaussian(t) for t in angles_rad]
    
    mc_angles_deg = np.linspace(1, 90, 100) # Reduzido para performance
    mc_angles_rad = np.radians(mc_angles_deg)
    cs_mc = [differential_cross_section_gaussian_mc(t) for t in mc_angles_rad]

    plt.figure(figsize=(9, 6))
    plt.plot(angles_deg, cs_analytical, label='Analítico (Gaussiano)', color='red', lw=2)
    plt.plot(mc_angles_deg, cs_mc, 'o', label=f'Monte Carlo (N={N})', color='blue')
    plt.yscale('log')
    plt.title(f'Espalhamento Gaussiano (E={E_MeV} MeV)')
    plt.xlabel("Ângulo de espalhamento θ (graus)")
    plt.ylabel("dσ/dΩ [m²/sr]")
    plt.grid(True, which='both', linestyle='--')
    plt.legend()
    plt.tight_layout()
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()

    results = {
        "plot": img_b64,
        "data": {
            "angle_ana_deg": angles_deg.tolist(),
            "cs_ana_m2_sr": cs_analytical,
            "angle_mc_deg": mc_angles_deg.tolist(),
            "cs_mc_m2_sr": cs_mc
        }
    }
    return json.dumps(results)
`;

const genericNumericalScript = `
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
import io, base64, json

def simulate(potential_type, N_samples, m_projectile_kg, **params):
    hbar, MeV_to_J, fm_to_m, eV_to_J, A_to_m = 1.05457e-34, 1.602e-13, 1e-15, 1.602e-19, 1e-10
    N_samples = int(N_samples)
    m = m_projectile_kg # Use projectile mass
    
    cs_ana_list, cs_mc_list = [], []
    theta_ana_deg, theta_mc_deg = [], []

    if potential_type == 'woods_saxon' or potential_type == 'morse':
        if potential_type == 'woods_saxon':
            V0, R, a, E_J = params['V0_MeV']*MeV_to_J, params['R_fm']*fm_to_m, params['a_fm']*fm_to_m, params['E_MeV']*MeV_to_J
            r_max = 20 * fm_to_m
            potential = lambda r: -V0 / (1 + np.exp((r - R) / a))
            title = f"Espalhamento Woods-Saxon (E={params['E_MeV']} MeV)"
        else: # Morse
            De, a, re, E_J = params['De_eV']*eV_to_J, params['a_A_inv']/A_to_m, params['re_A']*A_to_m, params['E_eV']*eV_to_J
            r_max = 5 * re
            potential = lambda r: De * (np.exp(-2 * a * (r - re)) - 2 * np.exp(-a * (r - re)))
            title = f"Espalhamento Morse (E={params['E_eV']} eV)"

        k = np.sqrt(2 * m * E_J) / hbar
        
        def numerical_cs(theta):
            q = 2 * k * np.sin(theta / 2)
            if abs(q) < 1e-9: return np.nan
            integrand = lambda r: r * potential(r) * np.sin(q * r)
            integral, _ = quad(integrand, 1e-15, r_max, limit=100)
            amplitude = - (2 * m / (hbar**2 * q)) * integral
            return abs(amplitude)**2

        def monte_carlo_cs(theta, N):
            q = 2 * k * np.sin(theta / 2)
            if abs(q) < 1e-9: return np.nan
            x, y, z = np.random.uniform(-r_max, r_max, (3, N))
            r = np.sqrt(x**2 + y**2 + z**2)
            r = np.maximum(r, 1e-20)
            integrand = np.where(r > 0, potential(r), 0) * np.cos(q * z)
            integral = (2 * r_max)**3 * np.mean(integrand)
            amplitude = -m / (2 * np.pi * hbar**2) * integral
            return np.abs(amplitude)**2
            
        theta_ana_rad = np.linspace(0.02, np.pi, 100)
        cs_ana_list = [numerical_cs(t) for t in theta_ana_rad]
        theta_ana_deg = np.degrees(theta_ana_rad).tolist()

        theta_mc_deg_np = np.linspace(5, 175, 100) # Reduzido para performance
        cs_mc_list = [monte_carlo_cs(t, int(N_samples/100)) for t in np.radians(theta_mc_deg_np)]
        theta_mc_deg = theta_mc_deg_np.tolist()

        plt.figure(figsize=(9, 6))
        plt.plot(theta_ana_deg, cs_ana_list, label='Numérico (Born)', lw=2, color='red')
        plt.plot(theta_mc_deg, cs_mc_list, 'o', label=f'Monte Carlo (N={N_samples})', color='blue')
        plt.yscale('log')

    elif potential_type == 'lennard_jones':
        epsilon, sigma, E_J = params['epsilon_eV']*eV_to_J, params['sigma_A']*A_to_m, params['E_eV']*eV_to_J
        title = f"Espalhamento Lennard-Jones (E={params['E_eV']} eV)"
        
        def lennard_jones_pot(r):
            r_safe = np.maximum(np.asarray(r), 1e-12)
            return 4 * epsilon * ((sigma / r_safe)**12 - (sigma / r_safe)**6)

        def born_amplitude(q):
            if q < 1e-9: return 0
            integrand = lambda r: lennard_jones_pot(r) * np.sin(q * r) / q * r**2
            result, _ = quad(integrand, 0.5 * sigma, 5 * sigma, limit=100)
            return - (2 * m / hbar**2) * result
            
        def numerical_cs(theta):
            k = np.sqrt(2 * m * E_J) / hbar
            q = 2 * k * np.sin(theta / 2)
            f_q = born_amplitude(q)
            return abs(f_q)**2

        def born_amplitude_mc(q, N_local):
            if q < 1e-9: return 0
            r_vals = np.random.uniform(0.5 * sigma, 5 * sigma, N_local)
            weights = lennard_jones_pot(r_vals) * np.sin(q * r_vals) / q * r_vals**2
            volume = 4.5 * sigma
            integral = np.mean(weights) * volume
            return - (2 * m / hbar**2) * integral
            
        def monte_carlo_cs(theta, N_local):
            k = np.sqrt(2 * m * E_J) / hbar
            q = 2 * k * np.sin(theta / 2)
            f_q = born_amplitude_mc(q, N_local)
            return abs(f_q)**2
        
        theta_ana_rad = np.linspace(0.02, np.pi, 100)
        cs_ana_list = [numerical_cs(t) for t in theta_ana_rad]
        theta_ana_deg = np.degrees(theta_ana_rad).tolist()
        
        theta_mc_rad = np.linspace(0.02, np.pi, 100) # Reduzido
        cs_mc_list = [monte_carlo_cs(t, int(N_samples/100)) for t in theta_mc_rad]
        theta_mc_deg = np.degrees(theta_mc_rad).tolist()
        
        plt.figure(figsize=(9, 6))
        plt.plot(theta_ana_deg, cs_ana_list, label='Born (Integração Numérica)', lw=2, color='red')
        plt.plot(theta_mc_deg, cs_mc_list,'o', label=f'Born (Monte Carlo N={N_samples})', color='blue')
        plt.yscale('log')

    plt.xlabel('Ângulo de espalhamento (graus)')
    plt.ylabel('dσ/dΩ [m²/sr]')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100)
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()

    results = {
        "plot": img_b64,
        "data": {
            "angle_ana_deg": theta_ana_deg,
            "cs_ana_m2_sr": cs_ana_list,
            "angle_mc_deg": theta_mc_deg,
            "cs_mc_m2_sr": cs_mc_list
        }
    }
    return json.dumps(results)
`;

pythonScripts.woods_saxon = genericNumericalScript;
pythonScripts.lennard_jones = genericNumericalScript;
pythonScripts.morse = genericNumericalScript;


// --- PAGE LOGIC ---
const select = document.getElementById('potential-select');
const particleSelect = document.getElementById('particle-select');
const targetSelect = document.getElementById('target-select');
const paramsContainer = document.getElementById('params-container');
const potentialEquationContainer = document.getElementById('potential-equation-container');
const potentialLinkContainer = document.getElementById('potential-link-container');
const runButton = document.getElementById('run-button');
const saveButton = document.getElementById('save-button');
const statusDiv = document.getElementById('status');
const plotOutput = document.getElementById('plot-output');
let pyodide;
let lastSimulationData = null;

function populateSelects() {
    for (const key in particleData) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = particleData[key].name;
        particleSelect.appendChild(option);
    }
    particleSelect.value = 'alpha'; // Padrão

    for (const key in targetData) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = `${targetData[key].name} (${key})`;
        targetSelect.appendChild(option);
    }
    targetSelect.value = 'Au'; // Padrão
}

function updateUI() {
    const selected = select.value;
    const data = potentialData[selected];
    paramsContainer.innerHTML = '';
    
    data.params.forEach(param => {
        const div = document.createElement('div');
        const label = document.createElement('label');
        label.setAttribute('for', param.id);
        label.textContent = param.label + ':';
        
        const input = document.createElement('input');
        input.type = 'number';
        input.id = param.id;
        input.value = param.value;
        input.step = "any";
        if (param.min !== undefined) input.min = param.min;
        div.appendChild(label);
        div.appendChild(input);
        paramsContainer.appendChild(div);
    });
    potentialEquationContainer.innerHTML = `<img src="${data.equation}" alt="Equação para ${data.name}">`;
    potentialLinkContainer.innerHTML = `<a href="${data.link}" target="_blank" rel="noopener noreferrer">Saiba mais sobre o Potencial de ${data.name}</a>`;
}

async function runSimulation() {
    statusDiv.textContent = 'Calculando... Por favor, aguarde.';
    runButton.disabled = true;
    saveButton.disabled = true;
    plotOutput.innerHTML = '';
    lastSimulationData = null;

    try {
        const selectedPotential = select.value;
        const script = pythonScripts[selectedPotential];
        
        // Coleta de parâmetros básicos
        const params = {};
        potentialData[selectedPotential].params.forEach(param => {
            params[param.id] = parseFloat(document.getElementById(param.id).value);
        });
        params['N_samples'] = parseFloat(document.getElementById('mc_samples').value);

        // Coleta de dados da partícula e do alvo
        const selectedParticleKey = particleSelect.value;
        const selectedTargetKey = targetSelect.value;
        const projectile = particleData[selectedParticleKey];
        const target = targetData[selectedTargetKey];

        params['m_projectile_kg'] = projectile.mass_kg;

        // Adiciona parâmetros específicos do potencial
        if (selectedPotential === 'rutherford') {
            params['Z1'] = projectile.charge_z;
            params['Z2'] = target.Z;
        } else if (selectedPotential === 'poco_quadrado') {
            params['A'] = target.A;
        }
        
        if (script === genericNumericalScript){
            params['potential_type'] = selectedPotential;
        }

        await pyodide.runPythonAsync(script);
        
        let pyParams = pyodide.toPy(params);
        pyodide.globals.set("py_params", pyParams);
        
        const result_json = await pyodide.runPythonAsync("simulate(**py_params)");
        const result_data = JSON.parse(result_json);
        
        // Armazena os parâmetros e os dados para salvar
        lastSimulationData = {
            parameters: { ...params, "Partícula": projectile.name, "Alvo": target.name },
            potentialName: potentialData[selectedPotential].name,
            results: result_data.data
        };
        
        plotOutput.innerHTML = `<img src="data:image/png;base64,${result_data.plot}" alt="Gráfico do resultado da simulação"/>`;
        statusDiv.textContent = 'Simulação concluída com sucesso!';
        saveButton.disabled = false;
        
        pyParams.destroy();

    } catch (error) {
        statusDiv.innerHTML = `Ocorreu um erro durante a simulação.<pre>${error.toString()}</pre>`;
        console.error("Pyodide Error:", error);
    } finally {
        runButton.disabled = false;
    }
}

function saveDataToExcel() {
    if (!lastSimulationData) {
        alert("Não há dados de simulação para salvar.");
        return;
    }

    // 1. Criar a aba de Parâmetros
    const params_ws_data = [
        ["Parâmetro", "Valor"],
        ["Tipo de Potencial", lastSimulationData.potentialName]
    ];
    for (const key in lastSimulationData.parameters) {
        if (key !== 'potential_type' && key !== 'm_projectile_kg') {
            let label = key;
            // Tenta encontrar um label mais amigável
            const pData = potentialData[select.value].params.find(p => p.id === key);
            if(pData) label = pData.label;

            params_ws_data.push([label, lastSimulationData.parameters[key]]);
        }
    }
    const params_ws = XLSX.utils.aoa_to_sheet(params_ws_data);

    // 2. Criar a aba de Resultados
    const res = lastSimulationData.results;
    const max_len = Math.max(res.angle_ana_deg.length, res.angle_mc_deg.length);
    const results_ws_data = [
        ["Ângulo Analítico (graus)", "dσ/dΩ Analítico (m²/sr)", "Ângulo Monte Carlo (graus)", "dσ/dΩ Monte Carlo (m²/sr)"]
    ];

    for (let i = 0; i < max_len; i++) {
        const row = [
            res.angle_ana_deg[i],
            res.cs_ana_m2_sr[i],
            res.angle_mc_deg[i],
            res.cs_mc_m2_sr[i]
        ];
        results_ws_data.push(row);
    }
    const results_ws = XLSX.utils.aoa_to_sheet(results_ws_data);

    // 3. Criar o Workbook e adicionar as abas
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, params_ws, "Parâmetros");
    XLSX.utils.book_append_sheet(wb, results_ws, "Resultados");

    // 4. Salvar o arquivo
    const potential_filename = lastSimulationData.potentialName.replace(/ /g, '_').toLowerCase();
    XLSX.writeFile(wb, `resultados_simulacao_${potential_filename}.xlsx`);
}


async function main() {
    statusDiv.textContent = 'Carregando ambiente Python (Pyodide)... Isso pode levar um momento.';
    runButton.disabled = true;
    saveButton.disabled = true;
    try {
        pyodide = await loadPyodide();
        await pyodide.loadPackage(['numpy', 'matplotlib', 'scipy']);
        statusDiv.textContent = 'Ambiente pronto. Selecione os parâmetros e clique em "Simular".';
        runButton.disabled = false;
    } catch (error) {
        statusDiv.innerHTML = `Falha ao carregar o ambiente Python.<pre>${error.toString()}</pre>`;
        console.error("Pyodide loading error:", error);
    }
}

select.addEventListener('change', updateUI);
runButton.addEventListener('click', runSimulation);
saveButton.addEventListener('click', saveDataToExcel);

document.addEventListener('DOMContentLoaded', () => {
    populateSelects();
    updateUI();
    main();
});
</script>
</body>
</html>
